package com.lexmachina;

import java.util.Arrays;
import java.util.List;

import com.querydsl.core.Tuple;
import com.querydsl.sql.SQLQuery;

import com.lexmachina.domain.QDcCase;
import com.lexmachina.domain.QDcDocketEntry;
import com.lexmachina.domain.QDcDocument;
import com.lexmachina.domain.QDcDocumentText;

public class ProcessDoc {

    // NOTE: Q* classes are generated by querydsl, must run maven build to generate
    // (and then re-sync with IDE if using one)

    private static QDcDocumentText documentTextT = QDcDocumentText.dcDocumentText;
    private static QDcDocument documentT = QDcDocument.dcDocument;
    private static QDcDocketEntry docketEntryT = QDcDocketEntry.dcDocketEntry;
    private static QDcCase caseT = QDcCase.dcCase;

    public static void main(String[] args) {
        DBReader dbReader = new DBReader();

        final int CASE_ID = 2001141372;
        final int DOCKET_ENTRY_ID = 2035035260;

        // subquery to get the document_text id of the highest priority document text for a given doc id
        SQLQuery<Integer> subQuery = dbReader.queryFactory().query()
                .select(documentTextT.id)
                .from(documentTextT)
                .orderBy(documentTextT.priority.desc(), documentTextT.timestamp.desc())
                .limit(1);

        //Added this. This query should get all docket ids for a give case.
        SQLQuery<Integer> allDocketsOfCaseID = dbReader.queryFactory().query()
                .select(docketEntryT.id)
                .from(docketEntryT)
                .where(docketEntryT.caseId.eq(CASE_ID));


        // all document text for all documents on a case


        SQLQuery<Tuple> query = dbReader.queryFactory().query()
                .select(documentT.id, documentTextT.id, documentTextT.rawText)
                .from(documentTextT)
                .join(documentT).on(documentTextT.documentId.eq(documentT.id))
                .where(documentT.docketEntryId.in(allDocketsOfCaseID)) //added this.
                .where(documentTextT.id.eq(subQuery.where(documentTextT.documentId.eq(documentT.id)))); //this seems to be ge

        System.out.println("query = " + query.getSQL().getSQL());

        List<Tuple> tuples = query.fetch();


        long attorneyCount = tuples.stream()
            .peek(t -> System.out.println("docId = " + t.get(documentT.id)))
            .map(t -> t.get(documentTextT.rawText))
            //.peek(t -> System.out.println("full text = " + t))
            .flatMap(s -> Arrays.stream(s.split("\\r?\\n|\\n")))
            .filter(s -> containsAttorneyRef((String)s))
            //.peek(t -> System.out.println("line = " + t))
            .count();

        System.out.println("attorneyCount = " + attorneyCount);
    }


    public static boolean containsAttorneyRef(String text){
        String lower = text.toLowerCase();
        //this can be made more efficent with streams.
        return lower.contains("attorney for") || lower.contains("attorneys for") || lower.contains("counsel for");
    }
}
